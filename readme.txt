Генетический алгоритм для обучения нейронной сети.
Реализовано обучение полносвязной нейронной сети (fully connected neural network).
Симуляция созданная по мотивам https://my-js.org/docs/guide/shorelark
Трейты алгоритмов остались как в исходнике:
- trait CrossoverMethod - кроссовер весов,
- trait MutationMethod - мутация весом одной хромосомы без изменения структуры,
- trait SelectionMethod - селекция детей.
За исключением того, что trait селекции возвращает не 1-го ребенка, а сразу 2-х.
Добавлен trait MutationMethodFlex - мутация весов и структуры хромосом в популяции.
Также есть trait Individual - для доступа к хромосоме и служебной информации по обучению. Он тоже
остался как в исходнике.
Добавлен trait IndividualFlex: Individual, в неё добавлена служебная информация для Flex обучения.
Эти трейты составляют основу ГА.

Основа ГА - хромосома Chromosome. Состоит из genes: Vec<(f32, usize, usize, usize)>, которая
имеет структуру (bias or weight, layer_num, neuron_out, neuron_in) совпадающая с
LayerTopologyFlex.connections.
По сравнению с исходником структура genes была изменена так, что теперь она помимо weight содержит
структуру сети: layer_num, neuron_out, neuron_in, и изменяется теперь не только bias or weight, но
и сама структура сети. Кстати, bias тоже не было в исходнике.
Для возможности изменения структуры сети в Chromosome дабавлены методы:
- from_weights_to_flex_net_view для создание представления Flex сети из весов.
- update_genes для обновления хромосомы из представления Flex сети.
Они используются в алгоритме мутации Flex1Mutation.

Старый алгоритм GeneticAlgorithm обучения (evolve) работал просто:
- На вход подавался массив Individual включающих хромосомы.
- Заполняется новая популяция через последовательность алгоритмов: (select), (crossover), (mutate).
- Создается статистика по предыдущему поколению Statistics::new.
- Возвращается новая популяция и статистика.

Новый алгоритм GeneticFlexAlgorithm обучения (evolve) работает:
- На вход подавался массив IndividualFlex включающих хромосомы.
- Создается статистика по предыдущему поколению Statistics::new. Теперь она нужна для обучения.
- fitness всех I делится на 4 диапазона. В зависимости от того, куда попадает fitness конкретного
I у него меняется life_time - сколько эпох осталось жить птичке, сила мутации.
~первая ~1/4 от диапазона: life_time -= 1, сильная мутация - веса + удаление/добавление слоя.
~вторая 1/4 от диапазона: life_time -= 1, средняя мутация - веса + удаление/доб. нейронов в слой.
~третья 1/4 от диапазона: life_time -= 1, слабая мутация - только веса.
~четвертая 1/4 от диапазона: life_time не меняется, нет мутации.
- При life_time 0, I идет под замену. Заполняется новый I через последовательность алгоритмов:
(select), (crossover).
- Иначе I остается и только мутирует, если сила мутации позволяет.
- Мутация новых I насколько позволяет сила мутации.
- Возвращается новая популяция и статистика (с учетом числа замененных I).

В статистике Statistics, кроме исходных min, max, avg, median fitness популяции, добавлено:
- changed_count, сколько I поменялось
- neurons_by_layer_all: HashSet<String>, сколько слоев и нейронов в каждом слое
- max_neuron_num: usize, номер максимального нейрона в популяции

Селекция SelectionMethod for RouletteWheelSelection изменилась по сравнению с исходной
только тем, что она теперь возвращает сразу 2 особи из популяции. Сделано было просто
для удобства.

Кроссовер CrossoverMethod for UniformCrossover поменялся по сравнению с исходным
тем, что приходится учитывать различие структур 2-х особей. В алгоритме мы
выбираем, структуру какой особи оставляем как базовую - она и будет на выходе.
А структуру 2-й особи накладываем "сверху". Это означает: если нейрона нет в 1-й особи,
то он не добавляется из 2-й особи. Если совпадение есть - происходит кроссовер
весов.

Мутация MutationMethod for GaussianMutation изменилась по сравнению с исходной
только тем, что её приспособили под структуру genes. Она используется в старом
алгоритме GeneticAlgorithm.

Мутация MutationMethodFlex for Flex1Mutation сложный алгоритм, который помимо весов
меняет структуру сети. Сначала определяется max номер нейрона по всей популяции.
Это нужно, чтобы понять под каким номером добавить новый нейрон в сеть. Похоже
в этом на алгоритм NEAT.
При мутации весов изменяется вес или bias, как и в GaussianMutation.
При добавлении или удалении нейрона не меняем входной и выходной слой. При удалении
нейрона, если он последний - не трогаем его. После этого обновляются все связи. Сам алгоритм
добавления нового нейрона состоит из 2-х фаз:
- фаза 1. Проходит обход всей популяции и каждой НС у особи. Каждому нейрону в сети
присваивается номер и составляется список слоев сетей популяции с максимальным номером нейрона,
присвоенным этому слою. Список имеет вид: <(слой,кол.нейронов слоя),макс.номер>.
- фаза 2. При добавлении нейрона в слой ему присваивается макс.номер для того кол.нейронов,
которое будет с ним, но у других сетей при добавлении нейрона в тот же слой при том же кол.в
слое присваивается тот же самый макс.номер. У разных слоев для каждого кол.нейронов в слое
свой макс. номер.
При добавлении слоя происходит удлинение хвоста сети, т.е. мы копируем последний
слой и наращиваем его. При удалении слоя мы не удаляем входной и выходной слой.
Удаляем слой с минимальным количеством нейронов (тот, который будет ближе к хвосту).
После этого обновляются все связи.
Для изменений нужно представление Flex сети: (inp_links, neurons), которое получается
из вида Vec<(f32, usize, usize, usize)> методом (Chromosome::from_weights_to_flex_net_view).
А когда изменения закончены необходимо перенести их обратно и обновить хромосомы,
через метод (update_genes).